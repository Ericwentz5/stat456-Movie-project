---
title: "Classifying and Predicting"
format: html
---
Sebastian Stefanowicz

AI Usage: Utilized generative AI to assist with modeling/predicting workflow (particularly model selection and evaluation criteria/functions/packages) and select appropriate visualizations to convey the desired message.

### Setup
```{r message=FALSE, warning=FALSE}
# Load packages and data
library(tidyverse)
library(ellmer)
library(dplyr)
library(tibble)
library(patchwork)
library(fastDummies)
library(caret)
library(pROC)
library(randomForest)
library(car)

imdb <- read_tsv("data/raw/title.basics.tsv")
movies_10k_w_llm <- read_csv("data/raw/10k_pre-2010-01-01-w-llm-classification.csv")
top_movies <- read_csv("data/top_10000_movies.csv")
```

# Training logit model

```{r message=FALSE}
unique(imdb$titleType)

imdb <- imdb %>% filter(titleType == "movie")

# Separating out genre arrays
imdb <- imdb %>%
  mutate(
    genres = str_split(genres, ",")
  ) %>%
  mutate(
    genre1 = map_chr(genres, ~ .x[1] %||% NA_character_),
    genre2 = map_chr(genres, ~ .x[2] %||% NA_character_),
    genre3 = map_chr(genres, ~ .x[3] %||% NA_character_)
  )

# Combining imdb and tmdb data
combined_movies <- movies_10k_w_llm %>% mutate(tconst = imdb_id) %>% left_join(imdb, by = "tconst")

# Remove movies with NA for genre1 and adding ROI predictor
combined_movies_filtered <- combined_movies %>% filter(!is.na(genre1)) %>% mutate(roi = revenue/budget)

unique(combined_movies_filtered$genre1)

# Create genre dummy variables
all_genres <- c("Drama", "Crime", "Biography", "Adventure", "Action", "Animation",
                "Comedy", "Horror", "Mystery", "Western", "Fantasy", "Thriller",
                "Sci-Fi", "Romance", "Film-Noir", "Family", "Musical", "Documentary")

combined_movies_filtered$genre1 <- factor(combined_movies_filtered$genre1,
                                          levels = all_genres)

combined_movies_filtered <- combined_movies_filtered %>%
  fastDummies::dummy_cols(select_columns = "genre1", remove_first_dummy = FALSE)

# Logistic Regression to see genres
model_logit1 <- glm(
  llm_class_final ~ vote_average + popularity + log(budget) + log(roi) + runtime + genre1,
  data = combined_movies_filtered,
  family = binomial
)

summary(model_logit1)

table(combined_movies_filtered$genre1)

# Logistics regression with only genres that are significant and have suitable sample size
model_logit2 <- glm(llm_class_final ~ vote_average + popularity + log(budget) + log(roi) + runtime + genre1_Biography + genre1_Action + genre1_Comedy + genre1_Horror + genre1_Fantasy,
                   data = combined_movies_filtered,
                   family = binomial)
summary(model_logit2)

# including log(budget) biases toward found footage/horror movies
```

### Testing logit prediction on 30% of training data before new data
```{r}
# Set seed for reproducibility
set.seed(123)

# Create index (70% train / 30% test)
train_idx <- createDataPartition(
  combined_movies_filtered$llm_class_final,
  p = 0.7,
  list = FALSE
)

# Bisecting data
train_data <- combined_movies_filtered[train_idx, ]
test_data  <- combined_movies_filtered[-train_idx, ]

# Checking balance
prop.table(table(train_data$llm_class_final))
prop.table(table(test_data$llm_class_final))

# Train logit model with training data
logit_train <- glm(llm_class_final ~ vote_average + popularity + log(budget) + log(roi) + runtime + genre1_Biography + genre1_Action + genre1_Comedy + genre1_Horror + genre1_Fantasy, 
                   data = train_data, 
                   family = binomial)
summary(logit_train)

# Predict logit on test set
test_data <- test_data %>%
  mutate(
    pred_prob_logit = predict(logit_train, newdata = ., type = "response"),
    pred_class_logit = if_else(pred_prob_logit >= 0.351, 1, 0)
  )
```

### Predicting with logit model
```{r}
top_movies <- top_movies %>%
  left_join(imdb, by = c("imdb_id" = "tconst"))

# Filter out training data and also movies released in past 6 months
top_movies_post2009 <- top_movies %>%
  filter(release_date >= as.Date("2010-01-01"), release_date < as.Date("2025-04-01"), budget > 10, revenue > 10) %>%
  mutate(roi = revenue/budget) %>%
  mutate(
    log_budget = log(budget),
    log_roi = log(roi)
  )

top_movies_post2009$genre1 <- factor(top_movies_post2009$genre1, levels = all_genres)

top_movies_post2009 <- top_movies_post2009 %>%
  fastDummies::dummy_cols(select_columns = "genre1", remove_first_dummy = FALSE)

# Predicting
top_movies_post2009_preds <- top_movies_post2009 %>%
  mutate(
    pred_prob_logit = predict(model_logit2, newdata = ., type = "response"),
    pred_class_logit = if_else(pred_prob_logit >= 0.351, 1, 0)
  )

# VIF to test for multicollinearity
vif(model_logit2)
```

### Testing rf prediction on 30% of training data before new data
```{r}
# Bisecting data
train_data$llm_class_final <- as.factor(train_data$llm_class_final)
test_data$llm_class_final  <- as.factor(test_data$llm_class_final)

# Logging predictors
train_data <- train_data %>%
mutate(
    log_budget = log(budget),
    log_roi = log(roi)
  )

test_data <- test_data %>%
mutate(
    log_budget = log(budget),
    log_roi = log(roi)
  )

# Running RF model
rf_train <- randomForest(
  llm_class_final ~ vote_average + popularity + log_budget + log_roi +
    runtime + genre1_Biography + genre1_Action + genre1_Comedy +
    genre1_Horror + genre1_Fantasy,
  data = train_data,
  ntree = 500,
  mtry = 4
)

# Predicting with RF model
test_data$pred_prob_rf <- predict(
  rf_train,
  newdata = test_data,
  type = "prob"
)[, 2]

test_data$pred_class_rf <- if_else(test_data$pred_prob_rf >= 0.351, 1, 0)

# Evaluate models
confusionMatrix(
  factor(test_data$pred_class_logit),
  factor(test_data$llm_class_final)
)

confusionMatrix(
  factor(test_data$pred_class_rf),
  factor(test_data$llm_class_final)
)

roc_logit <- roc(test_data$llm_class_final, test_data$pred_prob_logit)
roc_rf    <- roc(test_data$llm_class_final, test_data$pred_prob_rf)

auc(roc_logit)
auc(roc_rf)

# Create ensemble model
test_data <- test_data %>%
  mutate(
    pred_prob_ensemble = (pred_prob_logit + pred_prob_rf) / 2,
    pred_class_ensemble = if_else(pred_prob_ensemble >= 0.351, 1, 0)
  )

# Evaluate ensemble model
confusionMatrix(
  factor(test_data$pred_class_ensemble),
  factor(test_data$llm_class_final)
)

roc_ens <- roc(test_data$llm_class_final, test_data$pred_prob_ensemble)
auc(roc_ens)

# Get optimal classification split
coords(roc_rf, "best", ret = "threshold")
```

### Predicting with random forest and ensemble models
```{r}
# Setting up data
combined_movies_filtered$llm_class_final <- as.factor(combined_movies_filtered$llm_class_final)

combined_movies_filtered <- combined_movies_filtered %>%
  mutate(
    log_budget = log(budget),
    log_roi = log(roi)
  )

# Running RF
rf_model <- randomForest(
  llm_class_final ~ vote_average + popularity + log_budget + log_roi + runtime + genre1_Biography + genre1_Action + genre1_Comedy + genre1_Horror + genre1_Fantasy,
  data = combined_movies_filtered,
  ntree = 500,
  mtry = 4
)

rf_model

# Evaluate RF
importance(rf_model)
varImpPlot(rf_model)

# Predict with RF
top_movies_post2009_preds$pred_prob_rf <- predict(rf_model, top_movies_post2009, type = "prob")[,2]
top_movies_post2009_preds$pred_class_rf <- if_else(top_movies_post2009_preds$pred_prob_rf > 0.351, 1, 0)


# Combine predictions to make ensemble model
top_movies_post2009_preds <- top_movies_post2009_preds %>% mutate(ensemble_prob = (pred_prob_logit + pred_prob_rf)/2)
top_movies_post2009_preds$ensemble_class <- if_else(top_movies_post2009_preds$ensemble_prob > 0.351, 1, 0)

# Remove movies with primary genre = horror
top_movies_post2009_preds_nohorror <- top_movies_post2009_preds %>% filter(genre1_Horror == 0)
```

### Visualizing results
```{r}
# Adding gut check films
manual_titles <- c(
  "What We Do in the Shadows",
  "Bottoms",
  "Shiva Baby",
  "Avengers: Infinity War",
  "The Holdovers",
  "Portrait of a Lady on Fire",
  "Good Time"
)

manual_rows <- top_movies_post2009_preds_nohorror %>%
  filter(title %in% manual_titles) %>%
  select(title, ensemble_prob, genre1, genre2)

# Select data for plot
viz_data <- top_movies_post2009_preds_nohorror %>%
  select(title, ensemble_prob, genre1, genre2) %>%
  filter(!is.na(ensemble_prob)) %>%
  arrange(desc(ensemble_prob))

top_n  <- 10
bottom_n <- 10

viz_data <- bind_rows(
  slice_head(viz_data, n = top_n),
  slice_tail(viz_data, n = bottom_n),
  manual_rows
) %>%
  distinct(title, .keep_all = TRUE) %>% 
  mutate(
    title = forcats::fct_reorder(title, ensemble_prob)
  )

# Set colors
okabe_ito <- c(
  "#E69F00",
  "#56B4E9",
  "#009E73",
  "#F0E442",
  "#0072B2",
  "#CC79A7"
)

# Plot
final_plot <- ggplot(viz_data, aes(
  x = ensemble_prob,
  y = title,
  color = genre1
)) +
  geom_point(size = 3) +
  geom_vline(xintercept = 0.5, linetype = "dashed", alpha = 0.5) +
  scale_color_manual(
    values = okabe_ito,
    name = "Primary Genre"
  ) +
  labs(
    title = "Non-Horror Films with Highest and Lowest Predicted Cult Status + Notable Cases",
    subtitle = "Based on Ensemble Model Predictions for Post-2009 Releases, Excluding Horror Films",
    x = "Predicted Probability of Cult Status",
    y = NULL
  ) +
  theme_minimal(base_size = 12) +
  theme(
    legend.position = "right",
    panel.grid.major.y = element_blank()
  )

final_plot

# write takeaways:
# fitted mean model of llm_class_final ~ vote_average + popularity + log(budget) + log(roi) + runtime + genre1_Biography + genre1_Action + genre1_Comedy + genre1_Horror + genre1_Fantasy (will write this nicely in latex) with both a logit and random forest
# withheld 30% of pre-2010 data from training to test models, random forest was marginally better but decided to utilize an ensemble model (average of both) for better prediction stability
# talk about model selection/evaluation criteria: high AUC, decent kappa, good sensitivity and specificity
# model heavily favors horror films due to the abundance of short, low budget found-footage style horror films with high ROIs
# excluded primary genre=horror from final viz
# takeaways: model dislikes biographies and adventure films, good at ignoring the box office hits, top films are mostly comedies, with quite a few comedy/horrors, many at the top do seem unconventional enough to become cult classics (heartbeats is about a french canadian love triangle, alps is a Greek psychological drama art film directed by Yorgos Lathimos (who has since gone on to direct very popular and well loved films like Poor Things and Bugonia), stiches is a comedy/horror killer clown movie), while others seem like generic comedy/romances or just unassuming
# ones i added outside top/bottom 10: infinity war is a gut check/it had better be low, bottoms+good time+what we do in the shadows glad they got some type of score but expected higher, portrait of a lady on fire and holdovers have the qualities but are too popular and universally liked to be higher

# ggsave("seb_final_plot.png", plot = final_plot, width = 12, height = 5, bg = "white")
```

### Heatmap (not used for final presentation)
```{r}
# Prepare data for heatmap
heatmap_data <- top_movies_post2009_preds %>%
  filter(!is.na(genre1), !is.na(genre2)) %>%
  mutate(
    genre1 = factor(genre1, levels = sort(unique(genre1))),
    genre2 = factor(genre2, levels = sort(unique(genre2)))
  ) %>%
  group_by(genre1, genre2) %>%
  summarise(
    mean_prob = mean(ensemble_prob, na.rm = TRUE),
    n = n(),
    .groups = "drop"
  ) %>%
  filter(n >= 10)

# Viz
ggplot(heatmap_data, aes(x = genre1, y = genre2, fill = mean_prob)) +
  geom_tile(color = "white", linewidth = 0.3) +
  scale_fill_viridis_c(
    name = "Mean cult probability",
    option = "magma",
    limits = c(0, 1)
  ) +
  labs(
    title = "Ensemble-Predicted Cult Status by Genre Combination",
    subtitle = "Mean predicted probability (test set)",
    x = "Primary genre",
    y = "Secondary genre"
  ) +
  theme_minimal()
```

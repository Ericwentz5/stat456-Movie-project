---
title: "FP4"
format: html
editor: visual
---

```{r echo=FALSE}
library(tidyverse)
library(ggplot2)
library(lubridate)
library(shiny)
library(bslib)
library(dplyr)
library(tidyr)
library(tibble)
library(stringr)
```

## Data

```{r}
movies_df <- read.csv("~/Documents/COMP 456/ml-32m/movies.csv")
ratings_df <- read.csv("~/Documents/COMP 456/ml-32m/ratings.csv")
```

## App

```{r}
# Extracts the release year from a title like "Movie (1999)"
release_year_from_title <- function(title_chr) {
  y <- stringr::str_match(title_chr, ".*\\((\\d{4})\\)")[, 2]
  y <- suppressWarnings(as.integer(y))
  if (is.na(y)) NA_integer_ else y
}

# Computes metrics from yearly counts
compute_curve_metrics <- function(df_year_counts, rel_year) {
  if (nrow(df_year_counts) == 0) {
    return(tibble(metric = character(), value = numeric()))
  }

  # Fills yearly gaps to make a complete series
  yrs <- seq(min(df_year_counts$year), max(df_year_counts$year), by = "year")
  grid <- tibble(year = yrs) %>%
    left_join(df_year_counts, by = "year") %>%
    mutate(n = replace_na(n, 0L))

  # Numeric time scaled to years
  tnum   <- as.numeric(grid$year)
  t_year <- (tnum - min(tnum)) / (60 * 60 * 24 * 365.25)

  # LOESS smooth; fallback to raw counts if it fails
  lo   <- try(loess(n ~ t_year, data = grid, span = 0.4, degree = 2), silent = TRUE)
  yhat <- if (inherits(lo, "try-error")) grid$n else pmax(0, as.numeric(predict(lo, newdata = data.frame(t_year = t_year))))

  # Release-year baseline
  obs_years         <- as.integer(format(grid$year, "%Y"))
  rel_year_final    <- if (!is.na(rel_year)) rel_year else min(obs_years, na.rm = TRUE)
  yrs_since_release <- obs_years - rel_year_final

  # Lifetime total on smoothed curve
  total <- sum(yhat, na.rm = TRUE)
  if (total <= 0) total <- sum(grid$n, na.rm = TRUE)

  # T50 is the years since the release to accumulate 50% of total activity
  csum <- cumsum(yhat)
  T50_idx <- which(csum >= 0.5 * total)[1]
  time_to_takeoff_T50 <- if (is.na(T50_idx)) NA_real_ else yrs_since_release[T50_idx]

  # The year of max activity minus release year
  peak_idx <- if (all(is.na(yhat))) NA_integer_ else which.max(yhat)
  peak_lag_years <- if (is.na(peak_idx)) NA_real_ else yrs_since_release[peak_idx]

  # Long-tail ratio: years 5–15 / years 0–2
  sum_window <- function(low, high) {
    sel <- which(yrs_since_release >= low & yrs_since_release <= high)
    sum(yhat[sel], na.rm = TRUE)
  }
  late_sum       <- sum_window(5, 15)
  early_sum      <- sum_window(0, 2)
  long_tail_ratio <- if (isTRUE(early_sum > 0)) late_sum / early_sum else NA_real_

  # time from peak until activity <= 50% of peak
  decay_half_life <- NA_real_
  if (!is.na(peak_idx) && length(yhat) > peak_idx) {
    half_level <- 0.5 * yhat[peak_idx]
    post       <- seq.int(peak_idx, length(yhat))
    below      <- post[which(yhat[post] <= half_level)[1]]
    if (!is.na(below)) {
      decay_half_life <- yrs_since_release[below] - yrs_since_release[peak_idx]
    }
  }

  tibble(
    metric = c(
      "time_to_takeoff_T50 (yrs)",
      "peak_lag_years",
      "long_tail_ratio_5_15_over_0_2",
      "decay_half_life_years"
    ),
    value = c(
      time_to_takeoff_T50,
      peak_lag_years,
      long_tail_ratio,
      decay_half_life
    )
  )
}

ui <- fluidPage(
  titlePanel("Ratings per Year (Scatter + LOESS)"),
  sidebarLayout(
    sidebarPanel(
      selectizeInput(
        "movie", "Movie (pick one):",
        choices = NULL, multiple = FALSE,
        options = list(
          placeholder = "Type to search…",
          maxOptions  = 1000
        )
      )
    ),
    mainPanel(
      plotOutput("plot", height = 520),
      tags$hr(),
      h4("Curve metrics"),
      tableOutput("metrics")
    )
  )
)


server <- function(input, output, session) {

  movies <- movies_df %>%
    transmute(
      movieId = as.character(movieId),
      title   = as.character(title)
    ) %>%
    distinct() %>%
    arrange(title)

  ratings <- ratings_df %>%
    transmute(
      movieId   = as.character(movieId),
      timestamp = as.numeric(timestamp),
      timestamp = if_else(timestamp > 1e12, timestamp / 1000, timestamp),
      ts        = as_datetime(timestamp, tz = "UTC")
    ) %>%
    filter(!is.na(ts)) %>%
    select(movieId, ts)

  # dropdown
  observeEvent(TRUE, {
    updateSelectizeInput(
      session, "movie",
      choices = setNames(movies$movieId, movies$title),
      server  = TRUE
    )
  }, once = TRUE)

  # counts per year for the selected movie
  movie_year_counts <- reactive({
    req(input$movie)
    ratings %>%
      filter(movieId == input$movie) %>%
      count(year = floor_date(ts, "year"))
  })

  # release year for the Selected movie 
  selected_release_year <- reactive({
    req(input$movie)
    movie_title <- movies %>%
      filter(movieId == input$movie) %>%
      pull(title) %>%
      first()
    ry <- release_year_from_title(movie_title)
    if (is.na(ry)) {
      df <- movie_year_counts()
      if (nrow(df) == 0) return(NA_integer_)
      as.integer(format(min(df$year), "%Y"))
    } else ry
  })

  # Metrics table 
  movie_metrics <- reactive({
    df <- movie_year_counts()
    req(nrow(df) > 0)
    compute_curve_metrics(df %>% arrange(year), rel_year = selected_release_year())
  })

  # scatterplot with LOESS
  output$plot <- renderPlot({
    df <- movie_year_counts()
    req(nrow(df) > 0)

    movie_title <- movies %>%
      filter(movieId == input$movie) %>%
      pull(title) %>%
      unique()

    ggplot(df, aes(x = year, y = n)) +
      geom_point(color = "darkred") +
      geom_smooth(method = "loess", se = FALSE, color = "steelblue", size = 1) +
      labs(
        x = "Year",
        y = "Number of ratings",
        title = paste0("Ratings activity for ", movie_title)
      ) +
      scale_x_datetime(date_breaks = "1 year", date_labels = "%Y") +
      theme_minimal()
  })

  # Metrics table output 
  output$metrics <- renderTable({
    m <- movie_metrics()
    m %>%
      mutate(value = round(as.numeric(value), 2))
  }, striped = TRUE, bordered = TRUE, spacing = "s")
}

shinyApp(ui, server)

```
## Interpretation
Each movie’s ratings-over-time was turned into four simple numbers:
1. How long it takes to get  50% of all ratings (time_to_takeoff_T50)
2. How many years until the biggest peak (peak_lag_years)
3. How strong the long tail is (extended trickle of attention after the release window) (long_tail_ratio_5_15_over_0_2)
4. How fast interest fades after the peak (decay_half_life_years)
Across movies, we see two clear patterns:
* Slow burn: they build slowly, peak many years later, get far more ratings in years 5–15 than at launch, and fade slowly. These look cult-leaning.
* Early spike: big right away, weak long tail, and fade fast—more mainstream.
You can pick any film in the app to see its curve and these four numbers. For example, Pride & Prejudice (2005) shows a slow burn: late peak, strong long tail, and steady interest after.

## AI statement
Chat GPT was used to debug and make the code work for the following sections:
- Fills yearly gaps
- fallback to raw counts if it fails
- time from peak until activity
